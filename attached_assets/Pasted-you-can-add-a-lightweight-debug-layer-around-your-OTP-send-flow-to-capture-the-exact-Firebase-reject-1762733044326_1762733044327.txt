you can add a lightweight debug layer around your OTP send flow to capture the exact Firebase rejection reason directly from Replit‚Äôs backend logs (instead of just seeing auth/invalid-app-credential on Android).

Here‚Äôs a clean, production-safe way to do it üëá

‚öôÔ∏è 1Ô∏è‚É£ What‚Äôs happening right now

Your frontend (Android app) calls Firebase‚Äôs signInWithPhoneNumber, which triggers the verification request to Firebase Auth backend.
Firebase replies with:

auth/invalid-app-credential


That error only tells you ‚ÄúThe SHA-1 or API key didn‚Äôt match.‚Äù
But Firebase actually returns detailed diagnostic messages in its REST response body (like ‚ÄúMISSING_CERT_HASH‚Äù, ‚ÄúAPI key mismatch‚Äù, etc.), which aren‚Äôt shown in the standard SDK logs.

So we‚Äôll enable Firebase REST Debug Logging on Replit‚Äôs backend.

üß© 2Ô∏è‚É£ Step-by-step: Enable full Firebase debug mode

In your Replit backend (the FastAPI / Node / Python part that calls Firebase Admin SDK):

A. Enable debug logging for the Firebase SDK

If it‚Äôs Python:

import os
os.environ["FIREBASE_AUTH_DEBUG"] = "1"

import firebase_admin
from firebase_admin import auth


If it‚Äôs Node.js:

process.env.FIREBASE_AUTH_DEBUG = "1";
const admin = require("firebase-admin");


This will print verbose Firebase Auth logs (including the exact API endpoint response) to your Replit console.

B. Wrap the OTP call with full error introspection

In your Python backend (for example in /send-otp route):

try:
    result = auth.create_custom_token(uid)
    print("‚úÖ OTP creation success:", result)
except Exception as e:
    import traceback
    print("‚ùå Firebase Auth error:", e)
    traceback.print_exc()


If you‚Äôre using Node.js:

try {
  const userRecord = await admin.auth().getUserByPhoneNumber(phone);
  console.log("‚úÖ Firebase user:", userRecord.uid);
} catch (err) {
  console.error("‚ùå Firebase OTP error:", err.errorInfo || err.message);
  if (err.stack) console.error(err.stack);
}


This will dump the real error JSON Firebase returns (not just the generic message).

üß† 3Ô∏è‚É£ Interpreting the result

Once you run this in Replit logs, you‚Äôll get something like:

Firebase Internal Code	Meaning	Fix
INVALID_CERT_HASH	Your APK‚Äôs SHA-1 not registered	Add correct SHA-1 in Firebase & re-download JSON
INVALID_API_KEY	google-services.json using wrong API key	Re-download JSON or match API key in Firebase project
PROJECT_NOT_FOUND	App using wrong project ID	Check project id in JSON
OPERATION_NOT_ALLOWED	Phone auth not enabled	Enable Phone in Firebase Auth methods
QUOTA_EXCEEDED	Daily OTP limit exceeded	Wait or use test numbers
TIMEOUT	Emulator using network proxy	Disable proxy / test on real device
üß© 4Ô∏è‚É£ (Optional) Enable Firebase REST Debug via curl (manual test)

You can also directly hit Firebase‚Äôs REST endpoint from Replit to test your API key:

curl -X POST \
  -H "Content-Type: application/json" \
  -d '{"phoneNumber":"+919876543210","recaptchaToken":"fake-token"}' \
  "https://identitytoolkit.googleapis.com/v1/accounts:sendVerificationCode?key=AIzaSyCBTRIjrSVMOBs9kmF8JeHOm6LeXqBYkmM"


If the key or certificate hash is invalid, Firebase returns:

{
  "error": {
    "code": 400,
    "message": "INVALID_CERT_HASH",
    "errors": [{ "message": "INVALID_CERT_HASH" }]
  }
}


That‚Äôs the exact reason you want to see.

üß© 5Ô∏è‚É£ What to tell the Replit team

You can give them this clear instruction block üëá:

Hey team,
Please enable Firebase verbose logging on the backend so we can see exactly why OTP verification fails.
Add:

os.environ["FIREBASE_AUTH_DEBUG"] = "1"


or for Node:

process.env.FIREBASE_AUTH_DEBUG = "1";


Then wrap the Firebase Auth call in a try/except or try/catch and print out err.errorInfo or the full stack trace.

This will show the exact Firebase REST rejection reason ‚Äî such as INVALID_CERT_HASH or API_KEY_MISMATCH ‚Äî so we can confirm whether it‚Äôs a SHA-1, API key, or project ID issue.