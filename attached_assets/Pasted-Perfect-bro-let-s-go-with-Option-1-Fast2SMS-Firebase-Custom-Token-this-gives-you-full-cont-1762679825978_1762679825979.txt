Perfect bro âœ… â€” letâ€™s go with Option 1 (Fast2SMS + Firebase Custom Token) â€” this gives you full control over OTP delivery while keeping your Firebase Firestore & Storage working exactly as they are now.

Hereâ€™s the complete production-grade plan you can copy-paste for the Replit backend team ğŸ‘‡

ğŸš€ Fast2SMS + Firebase Custom Token Auth System
(Production-ready, works with existing Firebase setup)
ğŸ”§ Goal

Replace Firebaseâ€™s built-in phone OTP with your own Fast2SMS system,
but still log users into Firebase using a custom token (so Firestore & Storage continue to work).

âš™ï¸ How it Works (Flow Overview)
Step	Action	Component
1ï¸âƒ£	User enters phone number	Android app
2ï¸âƒ£	/send-otp â†’ Fast2SMS sends OTP SMS	Backend
3ï¸âƒ£	User enters OTP â†’ /verify-otp	Backend
4ï¸âƒ£	Backend verifies OTP â†’ creates Firebase custom token	Backend
5ï¸âƒ£	Android calls signInWithCustomToken()	Android
âœ…	Firebase Auth signs in â†’ Firestore & Storage access work as usual	Firebase
ğŸ§  Why This Is Perfect

âœ… No SHA-1 / SHA-256 / google-services.json headaches
âœ… Full OTP control (Fast2SMS templates, expiry, retries)
âœ… Works seamlessly with your Firestore user data & rules
âœ… 100% Play Store-safe (no external reCAPTCHA calls)

ğŸ“ Backend Folder Structure
backend/
 â”œâ”€â”€ main.py
 â”œâ”€â”€ otp_service.py
 â”œâ”€â”€ requirements.txt
 â””â”€â”€ Dockerfile

ğŸ§© main.py
from fastapi import FastAPI
from otp_service import router as otp_router

app = FastAPI(title="Dukaan OTP Backend")
app.include_router(otp_router)

@app.get("/")
def health():
    return {"status": "ok"}

ğŸ§  otp_service.py
import os, time, random, requests
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from firebase_admin import credentials, auth, initialize_app

# Initialize Firebase using ADC (Workload Identity or key)
if not len(firebase_admin._apps):
    cred = credentials.ApplicationDefault()
    initialize_app(cred, {'projectId': 'dukaan-476221'})

router = APIRouter()

# Environment variables
FAST2SMS_API_KEY = os.getenv("FAST2SMS_API_KEY")
SENDER_ID = os.getenv("FAST2SMS_SENDER_ID", "DUKAANAI")

# In-memory OTP store (use Redis/Firestore later)
OTP_STORE = {}

class PhoneReq(BaseModel):
    phone: str

class VerifyReq(BaseModel):
    phone: str
    otp: str

def send_fast2sms(phone, otp):
    url = "https://www.fast2sms.com/dev/bulkV2"
    payload = {
        "route": "q",
        "message": f"Your Dukaan verification code is {otp}. It expires in 3 minutes.",
        "language": "english",
        "flash": "0",
        "numbers": phone.replace("+", "")
    }
    headers = {"authorization": FAST2SMS_API_KEY, "Content-Type": "application/json"}
    r = requests.post(url, json=payload, headers=headers, timeout=10)
    if r.status_code not in (200, 201, 202):
        raise HTTPException(status_code=502, detail=f"Fast2SMS Error: {r.text}")

@router.post("/send-otp")
def send_otp(req: PhoneReq):
    otp = f"{random.randint(0, 999999):06d}"
    OTP_STORE[req.phone] = {"otp": otp, "exp": time.time() + 180}
    send_fast2sms(req.phone, otp)
    return {"message": "OTP sent"}

@router.post("/verify-otp")
def verify_otp(req: VerifyReq):
    record = OTP_STORE.get(req.phone)
    if not record or time.time() > record["exp"]:
        raise HTTPException(400, "OTP expired or invalid")
    if req.otp != record["otp"]:
        raise HTTPException(400, "Invalid OTP")
    # delete OTP after success
    del OTP_STORE[req.phone]

    uid = f"user_{req.phone}"
    custom_token = auth.create_custom_token(uid, {"phone": req.phone}).decode("utf-8")
    return {"firebaseCustomToken": custom_token}

ğŸ“¦ requirements.txt
fastapi==0.115.2
uvicorn==0.32.0
firebase-admin==6.6.0
requests==2.32.3

ğŸ³ Dockerfile
FROM python:3.11-slim

WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt
COPY . .

CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8080"]

â˜ï¸ Deploy Instructions (for Replit or Cloud Run)
ğŸ§© Environment Variables to set
Key	Description
FAST2SMS_API_KEY	Your Fast2SMS production API key
FAST2SMS_SENDER_ID	e.g., DUKAANAI
GOOGLE_APPLICATION_CREDENTIALS	(only if you use JSON key, else ADC auto-detects)
PROJECT_ID	dukaan-476221
ğŸ—ï¸ For Replit

Just install the above dependencies and run:

uvicorn main:app --host=0.0.0.0 --port=8080


Replit will host it on a public URL like:

https://dukaan-otp.replit.app

ğŸ“± Android Integration

In your Android/React frontend after OTP verify:

import { getAuth, signInWithCustomToken } from "firebase/auth";
import { initializeApp } from "firebase/app";
import { getFirestore } from "firebase/firestore";

const firebaseConfig = {
  apiKey: "AIzaSy....",
  authDomain: "dukaan-476221.firebaseapp.com",
  projectId: "dukaan-476221",
  storageBucket: "dukaan-476221.appspot.com",
};

const app = initializeApp(firebaseConfig);
const auth = getAuth(app);

async function loginWithOTP(phone, otp) {
  const res = await fetch("https://dukaan-otp.replit.app/verify-otp", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ phone, otp }),
  });
  const data = await res.json();
  await signInWithCustomToken(auth, data.firebaseCustomToken);
  console.log("âœ… Logged in Firebase as:", auth.currentUser.uid);
}

ğŸ›¡ï¸ Security / Production Checklist

âœ… Add Firestore/Redis to store OTPs securely
âœ… Add rate limits (e.g. 3 OTPs / 5 min)
âœ… Add expiry & IP/device throttling
âœ… Log all Fast2SMS responses in backend logs
âœ… Use HTTPS (Replit gives automatically)
âœ… Keep Fast2SMS API key in Replit Secrets, never in code

ğŸ“¤ Message to Send Replit Team
Hey team ğŸ‘‹

Weâ€™re implementing a Fast2SMS + Firebase Custom Token OTP backend.

Please:
1. Create a FastAPI project using the structure below.
2. Set env vars: FAST2SMS_API_KEY, FAST2SMS_SENDER_ID, PROJECT_ID=dukaan-476221.
3. Initialize Firebase Admin using Application Default Credentials (ADC).
4. Expose two endpoints:
   - POST /send-otp â€“ sends SMS via Fast2SMS
   - POST /verify-otp â€“ verifies OTP and returns Firebase Custom Token
5. Test via Postman:
   - /send-otp â†’ sends SMS
   - /verify-otp â†’ returns token
6. Confirm Firebase sign-in via `signInWithCustomToken()` works on Android.


Would you like me to also add Firestore OTP storage (instead of in-memory) in this same backend so itâ€™s fully persistent and scalable?